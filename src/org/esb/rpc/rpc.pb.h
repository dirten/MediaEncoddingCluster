// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#ifndef PROTOBUF_rpc_2eproto__INCLUDED
#define PROTOBUF_rpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
// @@protoc_insertion_point(includes)

namespace org {
namespace esb {
namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rpc_2eproto();
void protobuf_AssignDesc_rpc_2eproto();
void protobuf_ShutdownFile_rpc_2eproto();

class Request;
class Response;
class QueryForServiceRequest;
class QueryForServiceResponse;
class Node;
class NodeList;
class ProcessUnit;
class ProcessUnitRequest;
class ProcessUnitResponse;
class Process;
class ProcessRequest;
class ProcessResponse;
class ApiRequest;
class Stream;
class Mediafile;
class MediafileList;
class MediafileRequest;
class MediafileResponse;

enum ErrorReason {
  NO_ERROR_OCCURRED = 0,
  BAD_REQUEST_DATA = 1,
  BAD_REQUEST_PROTO = 2,
  SERVICE_NOT_FOUND = 3,
  METHOD_NOT_FOUND = 4,
  RPC_ERROR = 5,
  RPC_FAILED = 6,
  INVALID_REQUEST_PROTO = 7,
  BAD_RESPONSE_PROTO = 8,
  UNKNOWN_HOST = 9,
  IO_ERROR = 10
};
bool ErrorReason_IsValid(int value);
const ErrorReason ErrorReason_MIN = NO_ERROR_OCCURRED;
const ErrorReason ErrorReason_MAX = IO_ERROR;
const int ErrorReason_ARRAYSIZE = ErrorReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorReason_descriptor();
inline const ::std::string& ErrorReason_Name(ErrorReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorReason_descriptor(), value);
}
inline bool ErrorReason_Parse(
    const ::std::string& name, ErrorReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorReason>(
    ErrorReason_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_name = 1;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  
  // required string method_name = 2;
  inline bool has_method_name() const;
  inline void clear_method_name();
  static const int kMethodNameFieldNumber = 2;
  inline const ::std::string& method_name() const;
  inline void set_method_name(const ::std::string& value);
  inline void set_method_name(const char* value);
  inline void set_method_name(const char* value, size_t size);
  inline ::std::string* mutable_method_name();
  
  // required bytes request_proto = 3;
  inline bool has_request_proto() const;
  inline void clear_request_proto();
  static const int kRequestProtoFieldNumber = 3;
  inline const ::std::string& request_proto() const;
  inline void set_request_proto(const ::std::string& value);
  inline void set_request_proto(const char* value);
  inline void set_request_proto(const void* value, size_t size);
  inline ::std::string* mutable_request_proto();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.Request)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* service_name_;
  static const ::std::string _default_service_name_;
  ::std::string* method_name_;
  static const ::std::string _default_method_name_;
  ::std::string* request_proto_;
  static const ::std::string _default_request_proto_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();
  
  Response(const Response& from);
  
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();
  
  void Swap(Response* other);
  
  // implements Message ----------------------------------------------
  
  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes response_proto = 1;
  inline bool has_response_proto() const;
  inline void clear_response_proto();
  static const int kResponseProtoFieldNumber = 1;
  inline const ::std::string& response_proto() const;
  inline void set_response_proto(const ::std::string& value);
  inline void set_response_proto(const char* value);
  inline void set_response_proto(const void* value, size_t size);
  inline ::std::string* mutable_response_proto();
  
  // optional string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  
  // optional bool callback = 3 [default = false];
  inline bool has_callback() const;
  inline void clear_callback();
  static const int kCallbackFieldNumber = 3;
  inline bool callback() const;
  inline void set_callback(bool value);
  
  // optional .org.esb.rpc.ErrorReason error_reason = 4;
  inline bool has_error_reason() const;
  inline void clear_error_reason();
  static const int kErrorReasonFieldNumber = 4;
  inline org::esb::rpc::ErrorReason error_reason() const;
  inline void set_error_reason(org::esb::rpc::ErrorReason value);
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.Response)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* response_proto_;
  static const ::std::string _default_response_proto_;
  ::std::string* error_;
  static const ::std::string _default_error_;
  bool callback_;
  int error_reason_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class QueryForServiceRequest : public ::google::protobuf::Message {
 public:
  QueryForServiceRequest();
  virtual ~QueryForServiceRequest();
  
  QueryForServiceRequest(const QueryForServiceRequest& from);
  
  inline QueryForServiceRequest& operator=(const QueryForServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryForServiceRequest& default_instance();
  
  void Swap(QueryForServiceRequest* other);
  
  // implements Message ----------------------------------------------
  
  QueryForServiceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryForServiceRequest& from);
  void MergeFrom(const QueryForServiceRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_name = 1;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.QueryForServiceRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* service_name_;
  static const ::std::string _default_service_name_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static QueryForServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class QueryForServiceResponse : public ::google::protobuf::Message {
 public:
  QueryForServiceResponse();
  virtual ~QueryForServiceResponse();
  
  QueryForServiceResponse(const QueryForServiceResponse& from);
  
  inline QueryForServiceResponse& operator=(const QueryForServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryForServiceResponse& default_instance();
  
  void Swap(QueryForServiceResponse* other);
  
  // implements Message ----------------------------------------------
  
  QueryForServiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryForServiceResponse& from);
  void MergeFrom(const QueryForServiceResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string service_name = 1;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  
  // required bool registered = 2 [default = false];
  inline bool has_registered() const;
  inline void clear_registered();
  static const int kRegisteredFieldNumber = 2;
  inline bool registered() const;
  inline void set_registered(bool value);
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.QueryForServiceResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* service_name_;
  static const ::std::string _default_service_name_;
  bool registered_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static QueryForServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();
  
  Node(const Node& from);
  
  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();
  
  void Swap(Node* other);
  
  // implements Message ----------------------------------------------
  
  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  
  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.Node)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* address_;
  static const ::std::string _default_address_;
  ::google::protobuf::int32 port_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class NodeList : public ::google::protobuf::Message {
 public:
  NodeList();
  virtual ~NodeList();
  
  NodeList(const NodeList& from);
  
  inline NodeList& operator=(const NodeList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeList& default_instance();
  
  void Swap(NodeList* other);
  
  // implements Message ----------------------------------------------
  
  NodeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeList& from);
  void MergeFrom(const NodeList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .org.esb.rpc.Node nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::org::esb::rpc::Node& nodes(int index) const;
  inline ::org::esb::rpc::Node* mutable_nodes(int index);
  inline ::org::esb::rpc::Node* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node >*
      mutable_nodes();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.NodeList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node > nodes_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NodeList* default_instance_;
};
// -------------------------------------------------------------------

class ProcessUnit : public ::google::protobuf::Message {
 public:
  ProcessUnit();
  virtual ~ProcessUnit();
  
  ProcessUnit(const ProcessUnit& from);
  
  inline ProcessUnit& operator=(const ProcessUnit& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessUnit& default_instance();
  
  void Swap(ProcessUnit* other);
  
  // implements Message ----------------------------------------------
  
  ProcessUnit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessUnit& from);
  void MergeFrom(const ProcessUnit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes serialized_data = 1;
  inline bool has_serialized_data() const;
  inline void clear_serialized_data();
  static const int kSerializedDataFieldNumber = 1;
  inline const ::std::string& serialized_data() const;
  inline void set_serialized_data(const ::std::string& value);
  inline void set_serialized_data(const char* value);
  inline void set_serialized_data(const void* value, size_t size);
  inline ::std::string* mutable_serialized_data();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessUnit)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* serialized_data_;
  static const ::std::string _default_serialized_data_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProcessUnit* default_instance_;
};
// -------------------------------------------------------------------

class ProcessUnitRequest : public ::google::protobuf::Message {
 public:
  ProcessUnitRequest();
  virtual ~ProcessUnitRequest();
  
  ProcessUnitRequest(const ProcessUnitRequest& from);
  
  inline ProcessUnitRequest& operator=(const ProcessUnitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessUnitRequest& default_instance();
  
  void Swap(ProcessUnitRequest* other);
  
  // implements Message ----------------------------------------------
  
  ProcessUnitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessUnitRequest& from);
  void MergeFrom(const ProcessUnitRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.esb.rpc.Node node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::org::esb::rpc::Node& node() const;
  inline ::org::esb::rpc::Node* mutable_node();
  
  // optional .org.esb.rpc.ProcessUnit unit_data = 2;
  inline bool has_unit_data() const;
  inline void clear_unit_data();
  static const int kUnitDataFieldNumber = 2;
  inline const ::org::esb::rpc::ProcessUnit& unit_data() const;
  inline ::org::esb::rpc::ProcessUnit* mutable_unit_data();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessUnitRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::org::esb::rpc::Node* node_;
  ::org::esb::rpc::ProcessUnit* unit_data_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProcessUnitRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProcessUnitResponse : public ::google::protobuf::Message {
 public:
  ProcessUnitResponse();
  virtual ~ProcessUnitResponse();
  
  ProcessUnitResponse(const ProcessUnitResponse& from);
  
  inline ProcessUnitResponse& operator=(const ProcessUnitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessUnitResponse& default_instance();
  
  void Swap(ProcessUnitResponse* other);
  
  // implements Message ----------------------------------------------
  
  ProcessUnitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessUnitResponse& from);
  void MergeFrom(const ProcessUnitResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .org.esb.rpc.ProcessUnit unit_data = 2;
  inline bool has_unit_data() const;
  inline void clear_unit_data();
  static const int kUnitDataFieldNumber = 2;
  inline const ::org::esb::rpc::ProcessUnit& unit_data() const;
  inline ::org::esb::rpc::ProcessUnit* mutable_unit_data();
  
  // required string status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessUnitResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::org::esb::rpc::ProcessUnit* unit_data_;
  ::std::string* status_;
  static const ::std::string _default_status_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProcessUnitResponse* default_instance_;
};
// -------------------------------------------------------------------

class Process : public ::google::protobuf::Message {
 public:
  Process();
  virtual ~Process();
  
  Process(const Process& from);
  
  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Process& default_instance();
  
  void Swap(Process* other);
  
  // implements Message ----------------------------------------------
  
  Process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Process& from);
  void MergeFrom(const Process& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string process_name = 1;
  inline bool has_process_name() const;
  inline void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  inline const ::std::string& process_name() const;
  inline void set_process_name(const ::std::string& value);
  inline void set_process_name(const char* value);
  inline void set_process_name(const char* value, size_t size);
  inline ::std::string* mutable_process_name();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.Process)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* process_name_;
  static const ::std::string _default_process_name_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Process* default_instance_;
};
// -------------------------------------------------------------------

class ProcessRequest : public ::google::protobuf::Message {
 public:
  ProcessRequest();
  virtual ~ProcessRequest();
  
  ProcessRequest(const ProcessRequest& from);
  
  inline ProcessRequest& operator=(const ProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessRequest& default_instance();
  
  void Swap(ProcessRequest* other);
  
  // implements Message ----------------------------------------------
  
  ProcessRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessRequest& from);
  void MergeFrom(const ProcessRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.esb.rpc.Node node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::org::esb::rpc::Node& node() const;
  inline ::org::esb::rpc::Node* mutable_node();
  
  // optional .org.esb.rpc.Process process_data = 2;
  inline bool has_process_data() const;
  inline void clear_process_data();
  static const int kProcessDataFieldNumber = 2;
  inline const ::org::esb::rpc::Process& process_data() const;
  inline ::org::esb::rpc::Process* mutable_process_data();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::org::esb::rpc::Node* node_;
  ::org::esb::rpc::Process* process_data_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProcessRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProcessResponse : public ::google::protobuf::Message {
 public:
  ProcessResponse();
  virtual ~ProcessResponse();
  
  ProcessResponse(const ProcessResponse& from);
  
  inline ProcessResponse& operator=(const ProcessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessResponse& default_instance();
  
  void Swap(ProcessResponse* other);
  
  // implements Message ----------------------------------------------
  
  ProcessResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessResponse& from);
  void MergeFrom(const ProcessResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .org.esb.rpc.Process process_data = 2;
  inline bool has_process_data() const;
  inline void clear_process_data();
  static const int kProcessDataFieldNumber = 2;
  inline const ::org::esb::rpc::Process& process_data() const;
  inline ::org::esb::rpc::Process* mutable_process_data();
  
  // required string status_message = 3;
  inline bool has_status_message() const;
  inline void clear_status_message();
  static const int kStatusMessageFieldNumber = 3;
  inline const ::std::string& status_message() const;
  inline void set_status_message(const ::std::string& value);
  inline void set_status_message(const char* value);
  inline void set_status_message(const char* value, size_t size);
  inline ::std::string* mutable_status_message();
  
  // required int32 status_code = 4;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 4;
  inline ::google::protobuf::int32 status_code() const;
  inline void set_status_code(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::org::esb::rpc::Process* process_data_;
  ::std::string* status_message_;
  static const ::std::string _default_status_message_;
  ::google::protobuf::int32 status_code_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ProcessResponse* default_instance_;
};
// -------------------------------------------------------------------

class ApiRequest : public ::google::protobuf::Message {
 public:
  ApiRequest();
  virtual ~ApiRequest();
  
  ApiRequest(const ApiRequest& from);
  
  inline ApiRequest& operator=(const ApiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ApiRequest& default_instance();
  
  void Swap(ApiRequest* other);
  
  // implements Message ----------------------------------------------
  
  ApiRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApiRequest& from);
  void MergeFrom(const ApiRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.ApiRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ApiRequest* default_instance_;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message {
 public:
  Stream();
  virtual ~Stream();
  
  Stream(const Stream& from);
  
  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();
  
  void Swap(Stream* other);
  
  // implements Message ----------------------------------------------
  
  Stream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.Stream)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class Mediafile : public ::google::protobuf::Message {
 public:
  Mediafile();
  virtual ~Mediafile();
  
  Mediafile(const Mediafile& from);
  
  inline Mediafile& operator=(const Mediafile& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mediafile& default_instance();
  
  void Swap(Mediafile* other);
  
  // implements Message ----------------------------------------------
  
  Mediafile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mediafile& from);
  void MergeFrom(const Mediafile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required string filename = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  
  // required int64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);
  
  // required int64 duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::int64 duration() const;
  inline void set_duration(::google::protobuf::int64 value);
  
  // required int32 stream_count = 5;
  inline bool has_stream_count() const;
  inline void clear_stream_count();
  static const int kStreamCountFieldNumber = 5;
  inline ::google::protobuf::int32 stream_count() const;
  inline void set_stream_count(::google::protobuf::int32 value);
  
  // repeated .org.esb.rpc.Stream streams = 6;
  inline int streams_size() const;
  inline void clear_streams();
  static const int kStreamsFieldNumber = 6;
  inline const ::org::esb::rpc::Stream& streams(int index) const;
  inline ::org::esb::rpc::Stream* mutable_streams(int index);
  inline ::org::esb::rpc::Stream* add_streams();
  inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream >&
      streams() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream >*
      mutable_streams();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.Mediafile)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::std::string* filename_;
  static const ::std::string _default_filename_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 duration_;
  ::google::protobuf::int32 stream_count_;
  ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream > streams_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Mediafile* default_instance_;
};
// -------------------------------------------------------------------

class MediafileList : public ::google::protobuf::Message {
 public:
  MediafileList();
  virtual ~MediafileList();
  
  MediafileList(const MediafileList& from);
  
  inline MediafileList& operator=(const MediafileList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MediafileList& default_instance();
  
  void Swap(MediafileList* other);
  
  // implements Message ----------------------------------------------
  
  MediafileList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediafileList& from);
  void MergeFrom(const MediafileList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .org.esb.rpc.Mediafile mediafiles = 1;
  inline int mediafiles_size() const;
  inline void clear_mediafiles();
  static const int kMediafilesFieldNumber = 1;
  inline const ::org::esb::rpc::Mediafile& mediafiles(int index) const;
  inline ::org::esb::rpc::Mediafile* mutable_mediafiles(int index);
  inline ::org::esb::rpc::Mediafile* add_mediafiles();
  inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >&
      mediafiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >*
      mutable_mediafiles();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.MediafileList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile > mediafiles_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MediafileList* default_instance_;
};
// -------------------------------------------------------------------

class MediafileRequest : public ::google::protobuf::Message {
 public:
  MediafileRequest();
  virtual ~MediafileRequest();
  
  MediafileRequest(const MediafileRequest& from);
  
  inline MediafileRequest& operator=(const MediafileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MediafileRequest& default_instance();
  
  void Swap(MediafileRequest* other);
  
  // implements Message ----------------------------------------------
  
  MediafileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediafileRequest& from);
  void MergeFrom(const MediafileRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.esb.rpc.Mediafile file = 1;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::org::esb::rpc::Mediafile& file() const;
  inline ::org::esb::rpc::Mediafile* mutable_file();
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.MediafileRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::org::esb::rpc::Mediafile* file_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MediafileRequest* default_instance_;
};
// -------------------------------------------------------------------

class MediafileResponse : public ::google::protobuf::Message {
 public:
  MediafileResponse();
  virtual ~MediafileResponse();
  
  MediafileResponse(const MediafileResponse& from);
  
  inline MediafileResponse& operator=(const MediafileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MediafileResponse& default_instance();
  
  void Swap(MediafileResponse* other);
  
  // implements Message ----------------------------------------------
  
  MediafileResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediafileResponse& from);
  void MergeFrom(const MediafileResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .org.esb.rpc.Mediafile mediafiles = 1;
  inline int mediafiles_size() const;
  inline void clear_mediafiles();
  static const int kMediafilesFieldNumber = 1;
  inline const ::org::esb::rpc::Mediafile& mediafiles(int index) const;
  inline ::org::esb::rpc::Mediafile* mutable_mediafiles(int index);
  inline ::org::esb::rpc::Mediafile* add_mediafiles();
  inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >&
      mediafiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >*
      mutable_mediafiles();
  
  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.esb.rpc.MediafileResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile > mediafiles_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MediafileResponse* default_instance_;
};
// ===================================================================

class DiscoveryService_Stub;

class DiscoveryService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline DiscoveryService() {};
 public:
  virtual ~DiscoveryService();
  
  typedef DiscoveryService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void QueryForService(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::QueryForServiceRequest* request,
                       ::org::esb::rpc::QueryForServiceResponse* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DiscoveryService);
};

class DiscoveryService_Stub : public DiscoveryService {
 public:
  DiscoveryService_Stub(::google::protobuf::RpcChannel* channel);
  DiscoveryService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~DiscoveryService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements DiscoveryService ------------------------------------------
  
  void QueryForService(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::QueryForServiceRequest* request,
                       ::org::esb::rpc::QueryForServiceResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DiscoveryService_Stub);
};


// -------------------------------------------------------------------

class NodeService_Stub;

class NodeService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline NodeService() {};
 public:
  virtual ~NodeService();
  
  typedef NodeService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void registerNode(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::Node* request,
                       ::org::esb::rpc::NodeList* response,
                       ::google::protobuf::Closure* done);
  virtual void unregisterNode(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::Node* request,
                       ::org::esb::rpc::NodeList* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(NodeService);
};

class NodeService_Stub : public NodeService {
 public:
  NodeService_Stub(::google::protobuf::RpcChannel* channel);
  NodeService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~NodeService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements NodeService ------------------------------------------
  
  void registerNode(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::Node* request,
                       ::org::esb::rpc::NodeList* response,
                       ::google::protobuf::Closure* done);
  void unregisterNode(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::Node* request,
                       ::org::esb::rpc::NodeList* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(NodeService_Stub);
};


// -------------------------------------------------------------------

class ProcessUnitService_Stub;

class ProcessUnitService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ProcessUnitService() {};
 public:
  virtual ~ProcessUnitService();
  
  typedef ProcessUnitService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void getProcessUnit(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessUnitRequest* request,
                       ::org::esb::rpc::ProcessUnitResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void putProcessUnit(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessUnitRequest* request,
                       ::org::esb::rpc::ProcessUnitResponse* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ProcessUnitService);
};

class ProcessUnitService_Stub : public ProcessUnitService {
 public:
  ProcessUnitService_Stub(::google::protobuf::RpcChannel* channel);
  ProcessUnitService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~ProcessUnitService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements ProcessUnitService ------------------------------------------
  
  void getProcessUnit(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessUnitRequest* request,
                       ::org::esb::rpc::ProcessUnitResponse* response,
                       ::google::protobuf::Closure* done);
  void putProcessUnit(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessUnitRequest* request,
                       ::org::esb::rpc::ProcessUnitResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ProcessUnitService_Stub);
};


// -------------------------------------------------------------------

class ProcessService_Stub;

class ProcessService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ProcessService() {};
 public:
  virtual ~ProcessService();
  
  typedef ProcessService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void startProcess(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void stopProcess(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void getProcessList(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ProcessService);
};

class ProcessService_Stub : public ProcessService {
 public:
  ProcessService_Stub(::google::protobuf::RpcChannel* channel);
  ProcessService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~ProcessService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements ProcessService ------------------------------------------
  
  void startProcess(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  void stopProcess(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  void getProcessList(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ProcessService_Stub);
};


// -------------------------------------------------------------------

class ApiService_Stub;

class ApiService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ApiService() {};
 public:
  virtual ~ApiService();
  
  typedef ApiService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void getMediafile(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void addMediafile(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void getMediafileList(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ApiService);
};

class ApiService_Stub : public ApiService {
 public:
  ApiService_Stub(::google::protobuf::RpcChannel* channel);
  ApiService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~ApiService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements ApiService ------------------------------------------
  
  void getMediafile(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  void addMediafile(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  void getMediafileList(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ApiService_Stub);
};


// ===================================================================


// ===================================================================

// Request

// required string service_name = 1;
inline bool Request::has_service_name() const {
  return _has_bit(0);
}
inline void Request::clear_service_name() {
  if (service_name_ != &_default_service_name_) {
    service_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Request::service_name() const {
  return *service_name_;
}
inline void Request::set_service_name(const ::std::string& value) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void Request::set_service_name(const char* value) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void Request::set_service_name(const char* value, size_t size) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_service_name() {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}

// required string method_name = 2;
inline bool Request::has_method_name() const {
  return _has_bit(1);
}
inline void Request::clear_method_name() {
  if (method_name_ != &_default_method_name_) {
    method_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Request::method_name() const {
  return *method_name_;
}
inline void Request::set_method_name(const ::std::string& value) {
  _set_bit(1);
  if (method_name_ == &_default_method_name_) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void Request::set_method_name(const char* value) {
  _set_bit(1);
  if (method_name_ == &_default_method_name_) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void Request::set_method_name(const char* value, size_t size) {
  _set_bit(1);
  if (method_name_ == &_default_method_name_) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_method_name() {
  _set_bit(1);
  if (method_name_ == &_default_method_name_) {
    method_name_ = new ::std::string;
  }
  return method_name_;
}

// required bytes request_proto = 3;
inline bool Request::has_request_proto() const {
  return _has_bit(2);
}
inline void Request::clear_request_proto() {
  if (request_proto_ != &_default_request_proto_) {
    request_proto_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Request::request_proto() const {
  return *request_proto_;
}
inline void Request::set_request_proto(const ::std::string& value) {
  _set_bit(2);
  if (request_proto_ == &_default_request_proto_) {
    request_proto_ = new ::std::string;
  }
  request_proto_->assign(value);
}
inline void Request::set_request_proto(const char* value) {
  _set_bit(2);
  if (request_proto_ == &_default_request_proto_) {
    request_proto_ = new ::std::string;
  }
  request_proto_->assign(value);
}
inline void Request::set_request_proto(const void* value, size_t size) {
  _set_bit(2);
  if (request_proto_ == &_default_request_proto_) {
    request_proto_ = new ::std::string;
  }
  request_proto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_request_proto() {
  _set_bit(2);
  if (request_proto_ == &_default_request_proto_) {
    request_proto_ = new ::std::string;
  }
  return request_proto_;
}

// -------------------------------------------------------------------

// Response

// optional bytes response_proto = 1;
inline bool Response::has_response_proto() const {
  return _has_bit(0);
}
inline void Response::clear_response_proto() {
  if (response_proto_ != &_default_response_proto_) {
    response_proto_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Response::response_proto() const {
  return *response_proto_;
}
inline void Response::set_response_proto(const ::std::string& value) {
  _set_bit(0);
  if (response_proto_ == &_default_response_proto_) {
    response_proto_ = new ::std::string;
  }
  response_proto_->assign(value);
}
inline void Response::set_response_proto(const char* value) {
  _set_bit(0);
  if (response_proto_ == &_default_response_proto_) {
    response_proto_ = new ::std::string;
  }
  response_proto_->assign(value);
}
inline void Response::set_response_proto(const void* value, size_t size) {
  _set_bit(0);
  if (response_proto_ == &_default_response_proto_) {
    response_proto_ = new ::std::string;
  }
  response_proto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_response_proto() {
  _set_bit(0);
  if (response_proto_ == &_default_response_proto_) {
    response_proto_ = new ::std::string;
  }
  return response_proto_;
}

// optional string error = 2;
inline bool Response::has_error() const {
  return _has_bit(1);
}
inline void Response::clear_error() {
  if (error_ != &_default_error_) {
    error_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Response::error() const {
  return *error_;
}
inline void Response::set_error(const ::std::string& value) {
  _set_bit(1);
  if (error_ == &_default_error_) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Response::set_error(const char* value) {
  _set_bit(1);
  if (error_ == &_default_error_) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Response::set_error(const char* value, size_t size) {
  _set_bit(1);
  if (error_ == &_default_error_) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_error() {
  _set_bit(1);
  if (error_ == &_default_error_) {
    error_ = new ::std::string;
  }
  return error_;
}

// optional bool callback = 3 [default = false];
inline bool Response::has_callback() const {
  return _has_bit(2);
}
inline void Response::clear_callback() {
  callback_ = false;
  _clear_bit(2);
}
inline bool Response::callback() const {
  return callback_;
}
inline void Response::set_callback(bool value) {
  _set_bit(2);
  callback_ = value;
}

// optional .org.esb.rpc.ErrorReason error_reason = 4;
inline bool Response::has_error_reason() const {
  return _has_bit(3);
}
inline void Response::clear_error_reason() {
  error_reason_ = 0;
  _clear_bit(3);
}
inline org::esb::rpc::ErrorReason Response::error_reason() const {
  return static_cast< org::esb::rpc::ErrorReason >(error_reason_);
}
inline void Response::set_error_reason(org::esb::rpc::ErrorReason value) {
  GOOGLE_DCHECK(org::esb::rpc::ErrorReason_IsValid(value));
  _set_bit(3);
  error_reason_ = value;
}

// -------------------------------------------------------------------

// QueryForServiceRequest

// required string service_name = 1;
inline bool QueryForServiceRequest::has_service_name() const {
  return _has_bit(0);
}
inline void QueryForServiceRequest::clear_service_name() {
  if (service_name_ != &_default_service_name_) {
    service_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& QueryForServiceRequest::service_name() const {
  return *service_name_;
}
inline void QueryForServiceRequest::set_service_name(const ::std::string& value) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void QueryForServiceRequest::set_service_name(const char* value) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void QueryForServiceRequest::set_service_name(const char* value, size_t size) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryForServiceRequest::mutable_service_name() {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}

// -------------------------------------------------------------------

// QueryForServiceResponse

// optional string service_name = 1;
inline bool QueryForServiceResponse::has_service_name() const {
  return _has_bit(0);
}
inline void QueryForServiceResponse::clear_service_name() {
  if (service_name_ != &_default_service_name_) {
    service_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& QueryForServiceResponse::service_name() const {
  return *service_name_;
}
inline void QueryForServiceResponse::set_service_name(const ::std::string& value) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void QueryForServiceResponse::set_service_name(const char* value) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void QueryForServiceResponse::set_service_name(const char* value, size_t size) {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryForServiceResponse::mutable_service_name() {
  _set_bit(0);
  if (service_name_ == &_default_service_name_) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}

// required bool registered = 2 [default = false];
inline bool QueryForServiceResponse::has_registered() const {
  return _has_bit(1);
}
inline void QueryForServiceResponse::clear_registered() {
  registered_ = false;
  _clear_bit(1);
}
inline bool QueryForServiceResponse::registered() const {
  return registered_;
}
inline void QueryForServiceResponse::set_registered(bool value) {
  _set_bit(1);
  registered_ = value;
}

// -------------------------------------------------------------------

// Node

// required string address = 1;
inline bool Node::has_address() const {
  return _has_bit(0);
}
inline void Node::clear_address() {
  if (address_ != &_default_address_) {
    address_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Node::address() const {
  return *address_;
}
inline void Node::set_address(const ::std::string& value) {
  _set_bit(0);
  if (address_ == &_default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Node::set_address(const char* value) {
  _set_bit(0);
  if (address_ == &_default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Node::set_address(const char* value, size_t size) {
  _set_bit(0);
  if (address_ == &_default_address_) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_address() {
  _set_bit(0);
  if (address_ == &_default_address_) {
    address_ = new ::std::string;
  }
  return address_;
}

// optional int32 port = 2;
inline bool Node::has_port() const {
  return _has_bit(1);
}
inline void Node::clear_port() {
  port_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Node::port() const {
  return port_;
}
inline void Node::set_port(::google::protobuf::int32 value) {
  _set_bit(1);
  port_ = value;
}

// optional string name = 3;
inline bool Node::has_name() const {
  return _has_bit(2);
}
inline void Node::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Node::name() const {
  return *name_;
}
inline void Node::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Node::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Node::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// NodeList

// repeated .org.esb.rpc.Node nodes = 1;
inline int NodeList::nodes_size() const {
  return nodes_.size();
}
inline void NodeList::clear_nodes() {
  nodes_.Clear();
}
inline const ::org::esb::rpc::Node& NodeList::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::org::esb::rpc::Node* NodeList::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::org::esb::rpc::Node* NodeList::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node >&
NodeList::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node >*
NodeList::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// ProcessUnit

// required bytes serialized_data = 1;
inline bool ProcessUnit::has_serialized_data() const {
  return _has_bit(0);
}
inline void ProcessUnit::clear_serialized_data() {
  if (serialized_data_ != &_default_serialized_data_) {
    serialized_data_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ProcessUnit::serialized_data() const {
  return *serialized_data_;
}
inline void ProcessUnit::set_serialized_data(const ::std::string& value) {
  _set_bit(0);
  if (serialized_data_ == &_default_serialized_data_) {
    serialized_data_ = new ::std::string;
  }
  serialized_data_->assign(value);
}
inline void ProcessUnit::set_serialized_data(const char* value) {
  _set_bit(0);
  if (serialized_data_ == &_default_serialized_data_) {
    serialized_data_ = new ::std::string;
  }
  serialized_data_->assign(value);
}
inline void ProcessUnit::set_serialized_data(const void* value, size_t size) {
  _set_bit(0);
  if (serialized_data_ == &_default_serialized_data_) {
    serialized_data_ = new ::std::string;
  }
  serialized_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessUnit::mutable_serialized_data() {
  _set_bit(0);
  if (serialized_data_ == &_default_serialized_data_) {
    serialized_data_ = new ::std::string;
  }
  return serialized_data_;
}

// -------------------------------------------------------------------

// ProcessUnitRequest

// required .org.esb.rpc.Node node = 1;
inline bool ProcessUnitRequest::has_node() const {
  return _has_bit(0);
}
inline void ProcessUnitRequest::clear_node() {
  if (node_ != NULL) node_->::org::esb::rpc::Node::Clear();
  _clear_bit(0);
}
inline const ::org::esb::rpc::Node& ProcessUnitRequest::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::org::esb::rpc::Node* ProcessUnitRequest::mutable_node() {
  _set_bit(0);
  if (node_ == NULL) node_ = new ::org::esb::rpc::Node;
  return node_;
}

// optional .org.esb.rpc.ProcessUnit unit_data = 2;
inline bool ProcessUnitRequest::has_unit_data() const {
  return _has_bit(1);
}
inline void ProcessUnitRequest::clear_unit_data() {
  if (unit_data_ != NULL) unit_data_->::org::esb::rpc::ProcessUnit::Clear();
  _clear_bit(1);
}
inline const ::org::esb::rpc::ProcessUnit& ProcessUnitRequest::unit_data() const {
  return unit_data_ != NULL ? *unit_data_ : *default_instance_->unit_data_;
}
inline ::org::esb::rpc::ProcessUnit* ProcessUnitRequest::mutable_unit_data() {
  _set_bit(1);
  if (unit_data_ == NULL) unit_data_ = new ::org::esb::rpc::ProcessUnit;
  return unit_data_;
}

// -------------------------------------------------------------------

// ProcessUnitResponse

// optional .org.esb.rpc.ProcessUnit unit_data = 2;
inline bool ProcessUnitResponse::has_unit_data() const {
  return _has_bit(0);
}
inline void ProcessUnitResponse::clear_unit_data() {
  if (unit_data_ != NULL) unit_data_->::org::esb::rpc::ProcessUnit::Clear();
  _clear_bit(0);
}
inline const ::org::esb::rpc::ProcessUnit& ProcessUnitResponse::unit_data() const {
  return unit_data_ != NULL ? *unit_data_ : *default_instance_->unit_data_;
}
inline ::org::esb::rpc::ProcessUnit* ProcessUnitResponse::mutable_unit_data() {
  _set_bit(0);
  if (unit_data_ == NULL) unit_data_ = new ::org::esb::rpc::ProcessUnit;
  return unit_data_;
}

// required string status = 3;
inline bool ProcessUnitResponse::has_status() const {
  return _has_bit(1);
}
inline void ProcessUnitResponse::clear_status() {
  if (status_ != &_default_status_) {
    status_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ProcessUnitResponse::status() const {
  return *status_;
}
inline void ProcessUnitResponse::set_status(const ::std::string& value) {
  _set_bit(1);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void ProcessUnitResponse::set_status(const char* value) {
  _set_bit(1);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void ProcessUnitResponse::set_status(const char* value, size_t size) {
  _set_bit(1);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessUnitResponse::mutable_status() {
  _set_bit(1);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  return status_;
}

// -------------------------------------------------------------------

// Process

// required string process_name = 1;
inline bool Process::has_process_name() const {
  return _has_bit(0);
}
inline void Process::clear_process_name() {
  if (process_name_ != &_default_process_name_) {
    process_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Process::process_name() const {
  return *process_name_;
}
inline void Process::set_process_name(const ::std::string& value) {
  _set_bit(0);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void Process::set_process_name(const char* value) {
  _set_bit(0);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void Process::set_process_name(const char* value, size_t size) {
  _set_bit(0);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Process::mutable_process_name() {
  _set_bit(0);
  if (process_name_ == &_default_process_name_) {
    process_name_ = new ::std::string;
  }
  return process_name_;
}

// -------------------------------------------------------------------

// ProcessRequest

// required .org.esb.rpc.Node node = 1;
inline bool ProcessRequest::has_node() const {
  return _has_bit(0);
}
inline void ProcessRequest::clear_node() {
  if (node_ != NULL) node_->::org::esb::rpc::Node::Clear();
  _clear_bit(0);
}
inline const ::org::esb::rpc::Node& ProcessRequest::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::org::esb::rpc::Node* ProcessRequest::mutable_node() {
  _set_bit(0);
  if (node_ == NULL) node_ = new ::org::esb::rpc::Node;
  return node_;
}

// optional .org.esb.rpc.Process process_data = 2;
inline bool ProcessRequest::has_process_data() const {
  return _has_bit(1);
}
inline void ProcessRequest::clear_process_data() {
  if (process_data_ != NULL) process_data_->::org::esb::rpc::Process::Clear();
  _clear_bit(1);
}
inline const ::org::esb::rpc::Process& ProcessRequest::process_data() const {
  return process_data_ != NULL ? *process_data_ : *default_instance_->process_data_;
}
inline ::org::esb::rpc::Process* ProcessRequest::mutable_process_data() {
  _set_bit(1);
  if (process_data_ == NULL) process_data_ = new ::org::esb::rpc::Process;
  return process_data_;
}

// -------------------------------------------------------------------

// ProcessResponse

// optional .org.esb.rpc.Process process_data = 2;
inline bool ProcessResponse::has_process_data() const {
  return _has_bit(0);
}
inline void ProcessResponse::clear_process_data() {
  if (process_data_ != NULL) process_data_->::org::esb::rpc::Process::Clear();
  _clear_bit(0);
}
inline const ::org::esb::rpc::Process& ProcessResponse::process_data() const {
  return process_data_ != NULL ? *process_data_ : *default_instance_->process_data_;
}
inline ::org::esb::rpc::Process* ProcessResponse::mutable_process_data() {
  _set_bit(0);
  if (process_data_ == NULL) process_data_ = new ::org::esb::rpc::Process;
  return process_data_;
}

// required string status_message = 3;
inline bool ProcessResponse::has_status_message() const {
  return _has_bit(1);
}
inline void ProcessResponse::clear_status_message() {
  if (status_message_ != &_default_status_message_) {
    status_message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ProcessResponse::status_message() const {
  return *status_message_;
}
inline void ProcessResponse::set_status_message(const ::std::string& value) {
  _set_bit(1);
  if (status_message_ == &_default_status_message_) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(value);
}
inline void ProcessResponse::set_status_message(const char* value) {
  _set_bit(1);
  if (status_message_ == &_default_status_message_) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(value);
}
inline void ProcessResponse::set_status_message(const char* value, size_t size) {
  _set_bit(1);
  if (status_message_ == &_default_status_message_) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessResponse::mutable_status_message() {
  _set_bit(1);
  if (status_message_ == &_default_status_message_) {
    status_message_ = new ::std::string;
  }
  return status_message_;
}

// required int32 status_code = 4;
inline bool ProcessResponse::has_status_code() const {
  return _has_bit(2);
}
inline void ProcessResponse::clear_status_code() {
  status_code_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 ProcessResponse::status_code() const {
  return status_code_;
}
inline void ProcessResponse::set_status_code(::google::protobuf::int32 value) {
  _set_bit(2);
  status_code_ = value;
}

// -------------------------------------------------------------------

// ApiRequest

// -------------------------------------------------------------------

// Stream

// -------------------------------------------------------------------

// Mediafile

// required int32 id = 1;
inline bool Mediafile::has_id() const {
  return _has_bit(0);
}
inline void Mediafile::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Mediafile::id() const {
  return id_;
}
inline void Mediafile::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// required string filename = 2;
inline bool Mediafile::has_filename() const {
  return _has_bit(1);
}
inline void Mediafile::clear_filename() {
  if (filename_ != &_default_filename_) {
    filename_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Mediafile::filename() const {
  return *filename_;
}
inline void Mediafile::set_filename(const ::std::string& value) {
  _set_bit(1);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Mediafile::set_filename(const char* value) {
  _set_bit(1);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Mediafile::set_filename(const char* value, size_t size) {
  _set_bit(1);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mediafile::mutable_filename() {
  _set_bit(1);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  return filename_;
}

// required int64 size = 3;
inline bool Mediafile::has_size() const {
  return _has_bit(2);
}
inline void Mediafile::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 Mediafile::size() const {
  return size_;
}
inline void Mediafile::set_size(::google::protobuf::int64 value) {
  _set_bit(2);
  size_ = value;
}

// required int64 duration = 4;
inline bool Mediafile::has_duration() const {
  return _has_bit(3);
}
inline void Mediafile::clear_duration() {
  duration_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 Mediafile::duration() const {
  return duration_;
}
inline void Mediafile::set_duration(::google::protobuf::int64 value) {
  _set_bit(3);
  duration_ = value;
}

// required int32 stream_count = 5;
inline bool Mediafile::has_stream_count() const {
  return _has_bit(4);
}
inline void Mediafile::clear_stream_count() {
  stream_count_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Mediafile::stream_count() const {
  return stream_count_;
}
inline void Mediafile::set_stream_count(::google::protobuf::int32 value) {
  _set_bit(4);
  stream_count_ = value;
}

// repeated .org.esb.rpc.Stream streams = 6;
inline int Mediafile::streams_size() const {
  return streams_.size();
}
inline void Mediafile::clear_streams() {
  streams_.Clear();
}
inline const ::org::esb::rpc::Stream& Mediafile::streams(int index) const {
  return streams_.Get(index);
}
inline ::org::esb::rpc::Stream* Mediafile::mutable_streams(int index) {
  return streams_.Mutable(index);
}
inline ::org::esb::rpc::Stream* Mediafile::add_streams() {
  return streams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream >&
Mediafile::streams() const {
  return streams_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream >*
Mediafile::mutable_streams() {
  return &streams_;
}

// -------------------------------------------------------------------

// MediafileList

// repeated .org.esb.rpc.Mediafile mediafiles = 1;
inline int MediafileList::mediafiles_size() const {
  return mediafiles_.size();
}
inline void MediafileList::clear_mediafiles() {
  mediafiles_.Clear();
}
inline const ::org::esb::rpc::Mediafile& MediafileList::mediafiles(int index) const {
  return mediafiles_.Get(index);
}
inline ::org::esb::rpc::Mediafile* MediafileList::mutable_mediafiles(int index) {
  return mediafiles_.Mutable(index);
}
inline ::org::esb::rpc::Mediafile* MediafileList::add_mediafiles() {
  return mediafiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >&
MediafileList::mediafiles() const {
  return mediafiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >*
MediafileList::mutable_mediafiles() {
  return &mediafiles_;
}

// -------------------------------------------------------------------

// MediafileRequest

// required .org.esb.rpc.Mediafile file = 1;
inline bool MediafileRequest::has_file() const {
  return _has_bit(0);
}
inline void MediafileRequest::clear_file() {
  if (file_ != NULL) file_->::org::esb::rpc::Mediafile::Clear();
  _clear_bit(0);
}
inline const ::org::esb::rpc::Mediafile& MediafileRequest::file() const {
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::org::esb::rpc::Mediafile* MediafileRequest::mutable_file() {
  _set_bit(0);
  if (file_ == NULL) file_ = new ::org::esb::rpc::Mediafile;
  return file_;
}

// -------------------------------------------------------------------

// MediafileResponse

// repeated .org.esb.rpc.Mediafile mediafiles = 1;
inline int MediafileResponse::mediafiles_size() const {
  return mediafiles_.size();
}
inline void MediafileResponse::clear_mediafiles() {
  mediafiles_.Clear();
}
inline const ::org::esb::rpc::Mediafile& MediafileResponse::mediafiles(int index) const {
  return mediafiles_.Get(index);
}
inline ::org::esb::rpc::Mediafile* MediafileResponse::mutable_mediafiles(int index) {
  return mediafiles_.Mutable(index);
}
inline ::org::esb::rpc::Mediafile* MediafileResponse::add_mediafiles() {
  return mediafiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >&
MediafileResponse::mediafiles() const {
  return mediafiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >*
MediafileResponse::mutable_mediafiles() {
  return &mediafiles_;
}

// required int32 status = 2;
inline bool MediafileResponse::has_status() const {
  return _has_bit(1);
}
inline void MediafileResponse::clear_status() {
  status_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MediafileResponse::status() const {
  return status_;
}
inline void MediafileResponse::set_status(::google::protobuf::int32 value) {
  _set_bit(1);
  status_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace esb
}  // namespace org

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< org::esb::rpc::ErrorReason>() {
  return org::esb::rpc::ErrorReason_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rpc_2eproto__INCLUDED
