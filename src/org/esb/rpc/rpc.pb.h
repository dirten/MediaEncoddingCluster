// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#ifndef PROTOBUF_rpc_2eproto__INCLUDED
#define PROTOBUF_rpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace org {
namespace esb {
namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rpc_2eproto();
void protobuf_AssignDesc_rpc_2eproto();
void protobuf_ShutdownFile_rpc_2eproto();

class Request;
class Response;
class QueryForServiceRequest;
class QueryForServiceResponse;
class Node;
class NodeList;
class ProcessUnit;
class ProcessUnitRequest;
class ProcessUnitResponse;
class Process;
class ProcessRequest;
class ProcessResponse;
class ApiRequest;
class Stream;
class Mediafile;
class MediafileList;
class MediafileRequest;
class MediafileResponse;
class User;
class AuthToken;

enum ErrorReason {
  NO_ERROR_OCCURRED = 0,
  BAD_REQUEST_DATA = 1,
  BAD_REQUEST_PROTO = 2,
  SERVICE_NOT_FOUND = 3,
  METHOD_NOT_FOUND = 4,
  RPC_ERROR = 5,
  RPC_FAILED = 6,
  INVALID_REQUEST_PROTO = 7,
  BAD_RESPONSE_PROTO = 8,
  UNKNOWN_HOST = 9,
  IO_ERROR = 10
};
bool ErrorReason_IsValid(int value);
const ErrorReason ErrorReason_MIN = NO_ERROR_OCCURRED;
const ErrorReason ErrorReason_MAX = IO_ERROR;
const int ErrorReason_ARRAYSIZE = ErrorReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorReason_descriptor();
inline const ::std::string& ErrorReason_Name(ErrorReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorReason_descriptor(), value);
}
inline bool ErrorReason_Parse(
    const ::std::string& name, ErrorReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorReason>(
    ErrorReason_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_name = 1;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  inline ::std::string* release_service_name();
  inline void set_allocated_service_name(::std::string* service_name);

  // required string method_name = 2;
  inline bool has_method_name() const;
  inline void clear_method_name();
  static const int kMethodNameFieldNumber = 2;
  inline const ::std::string& method_name() const;
  inline void set_method_name(const ::std::string& value);
  inline void set_method_name(const char* value);
  inline void set_method_name(const char* value, size_t size);
  inline ::std::string* mutable_method_name();
  inline ::std::string* release_method_name();
  inline void set_allocated_method_name(::std::string* method_name);

  // required bytes request_proto = 3;
  inline bool has_request_proto() const;
  inline void clear_request_proto();
  static const int kRequestProtoFieldNumber = 3;
  inline const ::std::string& request_proto() const;
  inline void set_request_proto(const ::std::string& value);
  inline void set_request_proto(const char* value);
  inline void set_request_proto(const void* value, size_t size);
  inline ::std::string* mutable_request_proto();
  inline ::std::string* release_request_proto();
  inline void set_allocated_request_proto(::std::string* request_proto);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.Request)
 private:
  inline void set_has_service_name();
  inline void clear_has_service_name();
  inline void set_has_method_name();
  inline void clear_has_method_name();
  inline void set_has_request_proto();
  inline void clear_has_request_proto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* service_name_;
  ::std::string* method_name_;
  ::std::string* request_proto_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes response_proto = 1;
  inline bool has_response_proto() const;
  inline void clear_response_proto();
  static const int kResponseProtoFieldNumber = 1;
  inline const ::std::string& response_proto() const;
  inline void set_response_proto(const ::std::string& value);
  inline void set_response_proto(const char* value);
  inline void set_response_proto(const void* value, size_t size);
  inline ::std::string* mutable_response_proto();
  inline ::std::string* release_response_proto();
  inline void set_allocated_response_proto(::std::string* response_proto);

  // optional string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional bool callback = 3 [default = false];
  inline bool has_callback() const;
  inline void clear_callback();
  static const int kCallbackFieldNumber = 3;
  inline bool callback() const;
  inline void set_callback(bool value);

  // optional .org.esb.rpc.ErrorReason error_reason = 4;
  inline bool has_error_reason() const;
  inline void clear_error_reason();
  static const int kErrorReasonFieldNumber = 4;
  inline ::org::esb::rpc::ErrorReason error_reason() const;
  inline void set_error_reason(::org::esb::rpc::ErrorReason value);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.Response)
 private:
  inline void set_has_response_proto();
  inline void clear_has_response_proto();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_callback();
  inline void clear_has_callback();
  inline void set_has_error_reason();
  inline void clear_has_error_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* response_proto_;
  ::std::string* error_;
  bool callback_;
  int error_reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class QueryForServiceRequest : public ::google::protobuf::Message {
 public:
  QueryForServiceRequest();
  virtual ~QueryForServiceRequest();

  QueryForServiceRequest(const QueryForServiceRequest& from);

  inline QueryForServiceRequest& operator=(const QueryForServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryForServiceRequest& default_instance();

  void Swap(QueryForServiceRequest* other);

  // implements Message ----------------------------------------------

  QueryForServiceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryForServiceRequest& from);
  void MergeFrom(const QueryForServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_name = 1;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  inline ::std::string* release_service_name();
  inline void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.QueryForServiceRequest)
 private:
  inline void set_has_service_name();
  inline void clear_has_service_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* service_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static QueryForServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class QueryForServiceResponse : public ::google::protobuf::Message {
 public:
  QueryForServiceResponse();
  virtual ~QueryForServiceResponse();

  QueryForServiceResponse(const QueryForServiceResponse& from);

  inline QueryForServiceResponse& operator=(const QueryForServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryForServiceResponse& default_instance();

  void Swap(QueryForServiceResponse* other);

  // implements Message ----------------------------------------------

  QueryForServiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryForServiceResponse& from);
  void MergeFrom(const QueryForServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_name = 1;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  inline ::std::string* release_service_name();
  inline void set_allocated_service_name(::std::string* service_name);

  // required bool registered = 2 [default = false];
  inline bool has_registered() const;
  inline void clear_registered();
  static const int kRegisteredFieldNumber = 2;
  inline bool registered() const;
  inline void set_registered(bool value);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.QueryForServiceResponse)
 private:
  inline void set_has_service_name();
  inline void clear_has_service_name();
  inline void set_has_registered();
  inline void clear_has_registered();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* service_name_;
  bool registered_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static QueryForServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.Node)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* address_;
  ::std::string* name_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class NodeList : public ::google::protobuf::Message {
 public:
  NodeList();
  virtual ~NodeList();

  NodeList(const NodeList& from);

  inline NodeList& operator=(const NodeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeList& default_instance();

  void Swap(NodeList* other);

  // implements Message ----------------------------------------------

  NodeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeList& from);
  void MergeFrom(const NodeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.esb.rpc.Node nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::org::esb::rpc::Node& nodes(int index) const;
  inline ::org::esb::rpc::Node* mutable_nodes(int index);
  inline ::org::esb::rpc::Node* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:org.esb.rpc.NodeList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static NodeList* default_instance_;
};
// -------------------------------------------------------------------

class ProcessUnit : public ::google::protobuf::Message {
 public:
  ProcessUnit();
  virtual ~ProcessUnit();

  ProcessUnit(const ProcessUnit& from);

  inline ProcessUnit& operator=(const ProcessUnit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessUnit& default_instance();

  void Swap(ProcessUnit* other);

  // implements Message ----------------------------------------------

  ProcessUnit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessUnit& from);
  void MergeFrom(const ProcessUnit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialized_data = 1;
  inline bool has_serialized_data() const;
  inline void clear_serialized_data();
  static const int kSerializedDataFieldNumber = 1;
  inline const ::std::string& serialized_data() const;
  inline void set_serialized_data(const ::std::string& value);
  inline void set_serialized_data(const char* value);
  inline void set_serialized_data(const void* value, size_t size);
  inline ::std::string* mutable_serialized_data();
  inline ::std::string* release_serialized_data();
  inline void set_allocated_serialized_data(::std::string* serialized_data);

  // required int32 source_stream = 2;
  inline bool has_source_stream() const;
  inline void clear_source_stream();
  static const int kSourceStreamFieldNumber = 2;
  inline ::google::protobuf::int32 source_stream() const;
  inline void set_source_stream(::google::protobuf::int32 value);

  // required int32 target_stream = 3;
  inline bool has_target_stream() const;
  inline void clear_target_stream();
  static const int kTargetStreamFieldNumber = 3;
  inline ::google::protobuf::int32 target_stream() const;
  inline void set_target_stream(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessUnit)
 private:
  inline void set_has_serialized_data();
  inline void clear_has_serialized_data();
  inline void set_has_source_stream();
  inline void clear_has_source_stream();
  inline void set_has_target_stream();
  inline void clear_has_target_stream();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* serialized_data_;
  ::google::protobuf::int32 source_stream_;
  ::google::protobuf::int32 target_stream_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static ProcessUnit* default_instance_;
};
// -------------------------------------------------------------------

class ProcessUnitRequest : public ::google::protobuf::Message {
 public:
  ProcessUnitRequest();
  virtual ~ProcessUnitRequest();

  ProcessUnitRequest(const ProcessUnitRequest& from);

  inline ProcessUnitRequest& operator=(const ProcessUnitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessUnitRequest& default_instance();

  void Swap(ProcessUnitRequest* other);

  // implements Message ----------------------------------------------

  ProcessUnitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessUnitRequest& from);
  void MergeFrom(const ProcessUnitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .org.esb.rpc.Node node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::org::esb::rpc::Node& node() const;
  inline ::org::esb::rpc::Node* mutable_node();
  inline ::org::esb::rpc::Node* release_node();
  inline void set_allocated_node(::org::esb::rpc::Node* node);

  // optional .org.esb.rpc.ProcessUnit unit_data = 2;
  inline bool has_unit_data() const;
  inline void clear_unit_data();
  static const int kUnitDataFieldNumber = 2;
  inline const ::org::esb::rpc::ProcessUnit& unit_data() const;
  inline ::org::esb::rpc::ProcessUnit* mutable_unit_data();
  inline ::org::esb::rpc::ProcessUnit* release_unit_data();
  inline void set_allocated_unit_data(::org::esb::rpc::ProcessUnit* unit_data);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessUnitRequest)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_unit_data();
  inline void clear_has_unit_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::org::esb::rpc::Node* node_;
  ::org::esb::rpc::ProcessUnit* unit_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static ProcessUnitRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProcessUnitResponse : public ::google::protobuf::Message {
 public:
  ProcessUnitResponse();
  virtual ~ProcessUnitResponse();

  ProcessUnitResponse(const ProcessUnitResponse& from);

  inline ProcessUnitResponse& operator=(const ProcessUnitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessUnitResponse& default_instance();

  void Swap(ProcessUnitResponse* other);

  // implements Message ----------------------------------------------

  ProcessUnitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessUnitResponse& from);
  void MergeFrom(const ProcessUnitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .org.esb.rpc.ProcessUnit unit_data = 2;
  inline bool has_unit_data() const;
  inline void clear_unit_data();
  static const int kUnitDataFieldNumber = 2;
  inline const ::org::esb::rpc::ProcessUnit& unit_data() const;
  inline ::org::esb::rpc::ProcessUnit* mutable_unit_data();
  inline ::org::esb::rpc::ProcessUnit* release_unit_data();
  inline void set_allocated_unit_data(::org::esb::rpc::ProcessUnit* unit_data);

  // required string status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessUnitResponse)
 private:
  inline void set_has_unit_data();
  inline void clear_has_unit_data();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::org::esb::rpc::ProcessUnit* unit_data_;
  ::std::string* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static ProcessUnitResponse* default_instance_;
};
// -------------------------------------------------------------------

class Process : public ::google::protobuf::Message {
 public:
  Process();
  virtual ~Process();

  Process(const Process& from);

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Process& default_instance();

  void Swap(Process* other);

  // implements Message ----------------------------------------------

  Process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Process& from);
  void MergeFrom(const Process& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string process_name = 1;
  inline bool has_process_name() const;
  inline void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  inline const ::std::string& process_name() const;
  inline void set_process_name(const ::std::string& value);
  inline void set_process_name(const char* value);
  inline void set_process_name(const char* value, size_t size);
  inline ::std::string* mutable_process_name();
  inline ::std::string* release_process_name();
  inline void set_allocated_process_name(::std::string* process_name);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.Process)
 private:
  inline void set_has_process_name();
  inline void clear_has_process_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* process_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static Process* default_instance_;
};
// -------------------------------------------------------------------

class ProcessRequest : public ::google::protobuf::Message {
 public:
  ProcessRequest();
  virtual ~ProcessRequest();

  ProcessRequest(const ProcessRequest& from);

  inline ProcessRequest& operator=(const ProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessRequest& default_instance();

  void Swap(ProcessRequest* other);

  // implements Message ----------------------------------------------

  ProcessRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessRequest& from);
  void MergeFrom(const ProcessRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .org.esb.rpc.Node node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::org::esb::rpc::Node& node() const;
  inline ::org::esb::rpc::Node* mutable_node();
  inline ::org::esb::rpc::Node* release_node();
  inline void set_allocated_node(::org::esb::rpc::Node* node);

  // optional .org.esb.rpc.Process process_data = 2;
  inline bool has_process_data() const;
  inline void clear_process_data();
  static const int kProcessDataFieldNumber = 2;
  inline const ::org::esb::rpc::Process& process_data() const;
  inline ::org::esb::rpc::Process* mutable_process_data();
  inline ::org::esb::rpc::Process* release_process_data();
  inline void set_allocated_process_data(::org::esb::rpc::Process* process_data);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessRequest)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_process_data();
  inline void clear_has_process_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::org::esb::rpc::Node* node_;
  ::org::esb::rpc::Process* process_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static ProcessRequest* default_instance_;
};
// -------------------------------------------------------------------

class ProcessResponse : public ::google::protobuf::Message {
 public:
  ProcessResponse();
  virtual ~ProcessResponse();

  ProcessResponse(const ProcessResponse& from);

  inline ProcessResponse& operator=(const ProcessResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessResponse& default_instance();

  void Swap(ProcessResponse* other);

  // implements Message ----------------------------------------------

  ProcessResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessResponse& from);
  void MergeFrom(const ProcessResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .org.esb.rpc.Process process_data = 2;
  inline bool has_process_data() const;
  inline void clear_process_data();
  static const int kProcessDataFieldNumber = 2;
  inline const ::org::esb::rpc::Process& process_data() const;
  inline ::org::esb::rpc::Process* mutable_process_data();
  inline ::org::esb::rpc::Process* release_process_data();
  inline void set_allocated_process_data(::org::esb::rpc::Process* process_data);

  // required string status_message = 3;
  inline bool has_status_message() const;
  inline void clear_status_message();
  static const int kStatusMessageFieldNumber = 3;
  inline const ::std::string& status_message() const;
  inline void set_status_message(const ::std::string& value);
  inline void set_status_message(const char* value);
  inline void set_status_message(const char* value, size_t size);
  inline ::std::string* mutable_status_message();
  inline ::std::string* release_status_message();
  inline void set_allocated_status_message(::std::string* status_message);

  // required int32 status_code = 4;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 4;
  inline ::google::protobuf::int32 status_code() const;
  inline void set_status_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.ProcessResponse)
 private:
  inline void set_has_process_data();
  inline void clear_has_process_data();
  inline void set_has_status_message();
  inline void clear_has_status_message();
  inline void set_has_status_code();
  inline void clear_has_status_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::org::esb::rpc::Process* process_data_;
  ::std::string* status_message_;
  ::google::protobuf::int32 status_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static ProcessResponse* default_instance_;
};
// -------------------------------------------------------------------

class ApiRequest : public ::google::protobuf::Message {
 public:
  ApiRequest();
  virtual ~ApiRequest();

  ApiRequest(const ApiRequest& from);

  inline ApiRequest& operator=(const ApiRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApiRequest& default_instance();

  void Swap(ApiRequest* other);

  // implements Message ----------------------------------------------

  ApiRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApiRequest& from);
  void MergeFrom(const ApiRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:org.esb.rpc.ApiRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static ApiRequest* default_instance_;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  void Swap(Stream* other);

  // implements Message ----------------------------------------------

  Stream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:org.esb.rpc.Stream)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class Mediafile : public ::google::protobuf::Message {
 public:
  Mediafile();
  virtual ~Mediafile();

  Mediafile(const Mediafile& from);

  inline Mediafile& operator=(const Mediafile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mediafile& default_instance();

  void Swap(Mediafile* other);

  // implements Message ----------------------------------------------

  Mediafile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mediafile& from);
  void MergeFrom(const Mediafile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string filename = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required int64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // required int64 duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::int64 duration() const;
  inline void set_duration(::google::protobuf::int64 value);

  // required int32 stream_count = 5;
  inline bool has_stream_count() const;
  inline void clear_stream_count();
  static const int kStreamCountFieldNumber = 5;
  inline ::google::protobuf::int32 stream_count() const;
  inline void set_stream_count(::google::protobuf::int32 value);

  // required string format = 6;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 6;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // repeated .org.esb.rpc.Stream streams = 7;
  inline int streams_size() const;
  inline void clear_streams();
  static const int kStreamsFieldNumber = 7;
  inline const ::org::esb::rpc::Stream& streams(int index) const;
  inline ::org::esb::rpc::Stream* mutable_streams(int index);
  inline ::org::esb::rpc::Stream* add_streams();
  inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream >&
      streams() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream >*
      mutable_streams();

  // @@protoc_insertion_point(class_scope:org.esb.rpc.Mediafile)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_stream_count();
  inline void clear_has_stream_count();
  inline void set_has_format();
  inline void clear_has_format();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 stream_count_;
  ::google::protobuf::int64 duration_;
  ::std::string* format_;
  ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream > streams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static Mediafile* default_instance_;
};
// -------------------------------------------------------------------

class MediafileList : public ::google::protobuf::Message {
 public:
  MediafileList();
  virtual ~MediafileList();

  MediafileList(const MediafileList& from);

  inline MediafileList& operator=(const MediafileList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediafileList& default_instance();

  void Swap(MediafileList* other);

  // implements Message ----------------------------------------------

  MediafileList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediafileList& from);
  void MergeFrom(const MediafileList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.esb.rpc.Mediafile mediafiles = 1;
  inline int mediafiles_size() const;
  inline void clear_mediafiles();
  static const int kMediafilesFieldNumber = 1;
  inline const ::org::esb::rpc::Mediafile& mediafiles(int index) const;
  inline ::org::esb::rpc::Mediafile* mutable_mediafiles(int index);
  inline ::org::esb::rpc::Mediafile* add_mediafiles();
  inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >&
      mediafiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >*
      mutable_mediafiles();

  // @@protoc_insertion_point(class_scope:org.esb.rpc.MediafileList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile > mediafiles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static MediafileList* default_instance_;
};
// -------------------------------------------------------------------

class MediafileRequest : public ::google::protobuf::Message {
 public:
  MediafileRequest();
  virtual ~MediafileRequest();

  MediafileRequest(const MediafileRequest& from);

  inline MediafileRequest& operator=(const MediafileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediafileRequest& default_instance();

  void Swap(MediafileRequest* other);

  // implements Message ----------------------------------------------

  MediafileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediafileRequest& from);
  void MergeFrom(const MediafileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .org.esb.rpc.Mediafile file = 1;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::org::esb::rpc::Mediafile& file() const;
  inline ::org::esb::rpc::Mediafile* mutable_file();
  inline ::org::esb::rpc::Mediafile* release_file();
  inline void set_allocated_file(::org::esb::rpc::Mediafile* file);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.MediafileRequest)
 private:
  inline void set_has_file();
  inline void clear_has_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::org::esb::rpc::Mediafile* file_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static MediafileRequest* default_instance_;
};
// -------------------------------------------------------------------

class MediafileResponse : public ::google::protobuf::Message {
 public:
  MediafileResponse();
  virtual ~MediafileResponse();

  MediafileResponse(const MediafileResponse& from);

  inline MediafileResponse& operator=(const MediafileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediafileResponse& default_instance();

  void Swap(MediafileResponse* other);

  // implements Message ----------------------------------------------

  MediafileResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediafileResponse& from);
  void MergeFrom(const MediafileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.esb.rpc.Mediafile mediafiles = 1;
  inline int mediafiles_size() const;
  inline void clear_mediafiles();
  static const int kMediafilesFieldNumber = 1;
  inline const ::org::esb::rpc::Mediafile& mediafiles(int index) const;
  inline ::org::esb::rpc::Mediafile* mutable_mediafiles(int index);
  inline ::org::esb::rpc::Mediafile* add_mediafiles();
  inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >&
      mediafiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >*
      mutable_mediafiles();

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.MediafileResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile > mediafiles_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static MediafileResponse* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline const ::std::string& pass() const;
  inline void set_pass(const ::std::string& value);
  inline void set_pass(const char* value);
  inline void set_pass(const char* value, size_t size);
  inline ::std::string* mutable_pass();
  inline ::std::string* release_pass();
  inline void set_allocated_pass(::std::string* pass);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.User)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pass();
  inline void clear_has_pass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* pass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class AuthToken : public ::google::protobuf::Message {
 public:
  AuthToken();
  virtual ~AuthToken();

  AuthToken(const AuthToken& from);

  inline AuthToken& operator=(const AuthToken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthToken& default_instance();

  void Swap(AuthToken* other);

  // implements Message ----------------------------------------------

  AuthToken* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthToken& from);
  void MergeFrom(const AuthToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:org.esb.rpc.AuthToken)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_2eproto();
  friend void protobuf_AssignDesc_rpc_2eproto();
  friend void protobuf_ShutdownFile_rpc_2eproto();

  void InitAsDefaultInstance();
  static AuthToken* default_instance_;
};
// ===================================================================

class DiscoveryService_Stub;

class DiscoveryService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline DiscoveryService() {};
 public:
  virtual ~DiscoveryService();

  typedef DiscoveryService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void QueryForService(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::QueryForServiceRequest* request,
                       ::org::esb::rpc::QueryForServiceResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DiscoveryService);
};

class DiscoveryService_Stub : public DiscoveryService {
 public:
  DiscoveryService_Stub(::google::protobuf::RpcChannel* channel);
  DiscoveryService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~DiscoveryService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements DiscoveryService ------------------------------------------

  void QueryForService(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::QueryForServiceRequest* request,
                       ::org::esb::rpc::QueryForServiceResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DiscoveryService_Stub);
};


// -------------------------------------------------------------------

class NodeService_Stub;

class NodeService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline NodeService() {};
 public:
  virtual ~NodeService();

  typedef NodeService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void registerNode(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::Node* request,
                       ::org::esb::rpc::NodeList* response,
                       ::google::protobuf::Closure* done);
  virtual void unregisterNode(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::Node* request,
                       ::org::esb::rpc::NodeList* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(NodeService);
};

class NodeService_Stub : public NodeService {
 public:
  NodeService_Stub(::google::protobuf::RpcChannel* channel);
  NodeService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~NodeService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements NodeService ------------------------------------------

  void registerNode(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::Node* request,
                       ::org::esb::rpc::NodeList* response,
                       ::google::protobuf::Closure* done);
  void unregisterNode(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::Node* request,
                       ::org::esb::rpc::NodeList* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(NodeService_Stub);
};


// -------------------------------------------------------------------

class ProcessUnitService_Stub;

class ProcessUnitService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ProcessUnitService() {};
 public:
  virtual ~ProcessUnitService();

  typedef ProcessUnitService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void getProcessUnit(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessUnitRequest* request,
                       ::org::esb::rpc::ProcessUnitResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void putProcessUnit(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessUnitRequest* request,
                       ::org::esb::rpc::ProcessUnitResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ProcessUnitService);
};

class ProcessUnitService_Stub : public ProcessUnitService {
 public:
  ProcessUnitService_Stub(::google::protobuf::RpcChannel* channel);
  ProcessUnitService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~ProcessUnitService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements ProcessUnitService ------------------------------------------

  void getProcessUnit(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessUnitRequest* request,
                       ::org::esb::rpc::ProcessUnitResponse* response,
                       ::google::protobuf::Closure* done);
  void putProcessUnit(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessUnitRequest* request,
                       ::org::esb::rpc::ProcessUnitResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ProcessUnitService_Stub);
};


// -------------------------------------------------------------------

class ProcessService_Stub;

class ProcessService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ProcessService() {};
 public:
  virtual ~ProcessService();

  typedef ProcessService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void startProcess(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void stopProcess(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void getProcessList(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ProcessService);
};

class ProcessService_Stub : public ProcessService {
 public:
  ProcessService_Stub(::google::protobuf::RpcChannel* channel);
  ProcessService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~ProcessService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements ProcessService ------------------------------------------

  void startProcess(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  void stopProcess(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
  void getProcessList(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::ProcessRequest* request,
                       ::org::esb::rpc::ProcessResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ProcessService_Stub);
};


// -------------------------------------------------------------------

class ApiService_Stub;

class ApiService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ApiService() {};
 public:
  virtual ~ApiService();

  typedef ApiService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void authenticate(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::User* request,
                       ::org::esb::rpc::AuthToken* response,
                       ::google::protobuf::Closure* done);
  virtual void getMediafile(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void addMediafile(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void getMediafileList(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ApiService);
};

class ApiService_Stub : public ApiService {
 public:
  ApiService_Stub(::google::protobuf::RpcChannel* channel);
  ApiService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~ApiService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements ApiService ------------------------------------------

  void authenticate(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::User* request,
                       ::org::esb::rpc::AuthToken* response,
                       ::google::protobuf::Closure* done);
  void getMediafile(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  void addMediafile(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
  void getMediafileList(::google::protobuf::RpcController* controller,
                       const ::org::esb::rpc::MediafileRequest* request,
                       ::org::esb::rpc::MediafileResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ApiService_Stub);
};


// ===================================================================


// ===================================================================

// Request

// required string service_name = 1;
inline bool Request::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& Request::service_name() const {
  return *service_name_;
}
inline void Request::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void Request::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void Request::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}
inline ::std::string* Request::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_service_name(::std::string* service_name) {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    delete service_name_;
  }
  if (service_name) {
    set_has_service_name();
    service_name_ = service_name;
  } else {
    clear_has_service_name();
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string method_name = 2;
inline bool Request::has_method_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_method_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_method_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_method_name() {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    method_name_->clear();
  }
  clear_has_method_name();
}
inline const ::std::string& Request::method_name() const {
  return *method_name_;
}
inline void Request::set_method_name(const ::std::string& value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void Request::set_method_name(const char* value) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void Request::set_method_name(const char* value, size_t size) {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_method_name() {
  set_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    method_name_ = new ::std::string;
  }
  return method_name_;
}
inline ::std::string* Request::release_method_name() {
  clear_has_method_name();
  if (method_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_name_;
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_method_name(::std::string* method_name) {
  if (method_name_ != &::google::protobuf::internal::kEmptyString) {
    delete method_name_;
  }
  if (method_name) {
    set_has_method_name();
    method_name_ = method_name;
  } else {
    clear_has_method_name();
    method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes request_proto = 3;
inline bool Request::has_request_proto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_request_proto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_request_proto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_request_proto() {
  if (request_proto_ != &::google::protobuf::internal::kEmptyString) {
    request_proto_->clear();
  }
  clear_has_request_proto();
}
inline const ::std::string& Request::request_proto() const {
  return *request_proto_;
}
inline void Request::set_request_proto(const ::std::string& value) {
  set_has_request_proto();
  if (request_proto_ == &::google::protobuf::internal::kEmptyString) {
    request_proto_ = new ::std::string;
  }
  request_proto_->assign(value);
}
inline void Request::set_request_proto(const char* value) {
  set_has_request_proto();
  if (request_proto_ == &::google::protobuf::internal::kEmptyString) {
    request_proto_ = new ::std::string;
  }
  request_proto_->assign(value);
}
inline void Request::set_request_proto(const void* value, size_t size) {
  set_has_request_proto();
  if (request_proto_ == &::google::protobuf::internal::kEmptyString) {
    request_proto_ = new ::std::string;
  }
  request_proto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_request_proto() {
  set_has_request_proto();
  if (request_proto_ == &::google::protobuf::internal::kEmptyString) {
    request_proto_ = new ::std::string;
  }
  return request_proto_;
}
inline ::std::string* Request::release_request_proto() {
  clear_has_request_proto();
  if (request_proto_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_proto_;
    request_proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_request_proto(::std::string* request_proto) {
  if (request_proto_ != &::google::protobuf::internal::kEmptyString) {
    delete request_proto_;
  }
  if (request_proto) {
    set_has_request_proto();
    request_proto_ = request_proto;
  } else {
    clear_has_request_proto();
    request_proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Response

// optional bytes response_proto = 1;
inline bool Response::has_response_proto() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_response_proto() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_response_proto() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_response_proto() {
  if (response_proto_ != &::google::protobuf::internal::kEmptyString) {
    response_proto_->clear();
  }
  clear_has_response_proto();
}
inline const ::std::string& Response::response_proto() const {
  return *response_proto_;
}
inline void Response::set_response_proto(const ::std::string& value) {
  set_has_response_proto();
  if (response_proto_ == &::google::protobuf::internal::kEmptyString) {
    response_proto_ = new ::std::string;
  }
  response_proto_->assign(value);
}
inline void Response::set_response_proto(const char* value) {
  set_has_response_proto();
  if (response_proto_ == &::google::protobuf::internal::kEmptyString) {
    response_proto_ = new ::std::string;
  }
  response_proto_->assign(value);
}
inline void Response::set_response_proto(const void* value, size_t size) {
  set_has_response_proto();
  if (response_proto_ == &::google::protobuf::internal::kEmptyString) {
    response_proto_ = new ::std::string;
  }
  response_proto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_response_proto() {
  set_has_response_proto();
  if (response_proto_ == &::google::protobuf::internal::kEmptyString) {
    response_proto_ = new ::std::string;
  }
  return response_proto_;
}
inline ::std::string* Response::release_response_proto() {
  clear_has_response_proto();
  if (response_proto_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_proto_;
    response_proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_response_proto(::std::string* response_proto) {
  if (response_proto_ != &::google::protobuf::internal::kEmptyString) {
    delete response_proto_;
  }
  if (response_proto) {
    set_has_response_proto();
    response_proto_ = response_proto;
  } else {
    clear_has_response_proto();
    response_proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error = 2;
inline bool Response::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& Response::error() const {
  return *error_;
}
inline void Response::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Response::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void Response::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* Response::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool callback = 3 [default = false];
inline bool Response::has_callback() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_callback() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_callback() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_callback() {
  callback_ = false;
  clear_has_callback();
}
inline bool Response::callback() const {
  return callback_;
}
inline void Response::set_callback(bool value) {
  set_has_callback();
  callback_ = value;
}

// optional .org.esb.rpc.ErrorReason error_reason = 4;
inline bool Response::has_error_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_error_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_error_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_error_reason() {
  error_reason_ = 0;
  clear_has_error_reason();
}
inline ::org::esb::rpc::ErrorReason Response::error_reason() const {
  return static_cast< ::org::esb::rpc::ErrorReason >(error_reason_);
}
inline void Response::set_error_reason(::org::esb::rpc::ErrorReason value) {
  assert(::org::esb::rpc::ErrorReason_IsValid(value));
  set_has_error_reason();
  error_reason_ = value;
}

// -------------------------------------------------------------------

// QueryForServiceRequest

// required string service_name = 1;
inline bool QueryForServiceRequest::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryForServiceRequest::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryForServiceRequest::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryForServiceRequest::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& QueryForServiceRequest::service_name() const {
  return *service_name_;
}
inline void QueryForServiceRequest::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void QueryForServiceRequest::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void QueryForServiceRequest::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryForServiceRequest::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}
inline ::std::string* QueryForServiceRequest::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryForServiceRequest::set_allocated_service_name(::std::string* service_name) {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    delete service_name_;
  }
  if (service_name) {
    set_has_service_name();
    service_name_ = service_name;
  } else {
    clear_has_service_name();
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryForServiceResponse

// optional string service_name = 1;
inline bool QueryForServiceResponse::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryForServiceResponse::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryForServiceResponse::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryForServiceResponse::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& QueryForServiceResponse::service_name() const {
  return *service_name_;
}
inline void QueryForServiceResponse::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void QueryForServiceResponse::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void QueryForServiceResponse::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryForServiceResponse::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}
inline ::std::string* QueryForServiceResponse::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryForServiceResponse::set_allocated_service_name(::std::string* service_name) {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    delete service_name_;
  }
  if (service_name) {
    set_has_service_name();
    service_name_ = service_name;
  } else {
    clear_has_service_name();
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool registered = 2 [default = false];
inline bool QueryForServiceResponse::has_registered() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryForServiceResponse::set_has_registered() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryForServiceResponse::clear_has_registered() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryForServiceResponse::clear_registered() {
  registered_ = false;
  clear_has_registered();
}
inline bool QueryForServiceResponse::registered() const {
  return registered_;
}
inline void QueryForServiceResponse::set_registered(bool value) {
  set_has_registered();
  registered_ = value;
}

// -------------------------------------------------------------------

// Node

// required string address = 1;
inline bool Node::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Node::address() const {
  return *address_;
}
inline void Node::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Node::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Node::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Node::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 2;
inline bool Node::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Node::port() const {
  return port_;
}
inline void Node::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional string name = 3;
inline bool Node::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Node::name() const {
  return *name_;
}
inline void Node::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Node::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Node::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Node::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NodeList

// repeated .org.esb.rpc.Node nodes = 1;
inline int NodeList::nodes_size() const {
  return nodes_.size();
}
inline void NodeList::clear_nodes() {
  nodes_.Clear();
}
inline const ::org::esb::rpc::Node& NodeList::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::org::esb::rpc::Node* NodeList::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::org::esb::rpc::Node* NodeList::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node >&
NodeList::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Node >*
NodeList::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// ProcessUnit

// required bytes serialized_data = 1;
inline bool ProcessUnit::has_serialized_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessUnit::set_has_serialized_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessUnit::clear_has_serialized_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessUnit::clear_serialized_data() {
  if (serialized_data_ != &::google::protobuf::internal::kEmptyString) {
    serialized_data_->clear();
  }
  clear_has_serialized_data();
}
inline const ::std::string& ProcessUnit::serialized_data() const {
  return *serialized_data_;
}
inline void ProcessUnit::set_serialized_data(const ::std::string& value) {
  set_has_serialized_data();
  if (serialized_data_ == &::google::protobuf::internal::kEmptyString) {
    serialized_data_ = new ::std::string;
  }
  serialized_data_->assign(value);
}
inline void ProcessUnit::set_serialized_data(const char* value) {
  set_has_serialized_data();
  if (serialized_data_ == &::google::protobuf::internal::kEmptyString) {
    serialized_data_ = new ::std::string;
  }
  serialized_data_->assign(value);
}
inline void ProcessUnit::set_serialized_data(const void* value, size_t size) {
  set_has_serialized_data();
  if (serialized_data_ == &::google::protobuf::internal::kEmptyString) {
    serialized_data_ = new ::std::string;
  }
  serialized_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessUnit::mutable_serialized_data() {
  set_has_serialized_data();
  if (serialized_data_ == &::google::protobuf::internal::kEmptyString) {
    serialized_data_ = new ::std::string;
  }
  return serialized_data_;
}
inline ::std::string* ProcessUnit::release_serialized_data() {
  clear_has_serialized_data();
  if (serialized_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_data_;
    serialized_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessUnit::set_allocated_serialized_data(::std::string* serialized_data) {
  if (serialized_data_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_data_;
  }
  if (serialized_data) {
    set_has_serialized_data();
    serialized_data_ = serialized_data;
  } else {
    clear_has_serialized_data();
    serialized_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 source_stream = 2;
inline bool ProcessUnit::has_source_stream() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessUnit::set_has_source_stream() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessUnit::clear_has_source_stream() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessUnit::clear_source_stream() {
  source_stream_ = 0;
  clear_has_source_stream();
}
inline ::google::protobuf::int32 ProcessUnit::source_stream() const {
  return source_stream_;
}
inline void ProcessUnit::set_source_stream(::google::protobuf::int32 value) {
  set_has_source_stream();
  source_stream_ = value;
}

// required int32 target_stream = 3;
inline bool ProcessUnit::has_target_stream() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessUnit::set_has_target_stream() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessUnit::clear_has_target_stream() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessUnit::clear_target_stream() {
  target_stream_ = 0;
  clear_has_target_stream();
}
inline ::google::protobuf::int32 ProcessUnit::target_stream() const {
  return target_stream_;
}
inline void ProcessUnit::set_target_stream(::google::protobuf::int32 value) {
  set_has_target_stream();
  target_stream_ = value;
}

// -------------------------------------------------------------------

// ProcessUnitRequest

// required .org.esb.rpc.Node node = 1;
inline bool ProcessUnitRequest::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessUnitRequest::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessUnitRequest::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessUnitRequest::clear_node() {
  if (node_ != NULL) node_->::org::esb::rpc::Node::Clear();
  clear_has_node();
}
inline const ::org::esb::rpc::Node& ProcessUnitRequest::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::org::esb::rpc::Node* ProcessUnitRequest::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::org::esb::rpc::Node;
  return node_;
}
inline ::org::esb::rpc::Node* ProcessUnitRequest::release_node() {
  clear_has_node();
  ::org::esb::rpc::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void ProcessUnitRequest::set_allocated_node(::org::esb::rpc::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
}

// optional .org.esb.rpc.ProcessUnit unit_data = 2;
inline bool ProcessUnitRequest::has_unit_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessUnitRequest::set_has_unit_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessUnitRequest::clear_has_unit_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessUnitRequest::clear_unit_data() {
  if (unit_data_ != NULL) unit_data_->::org::esb::rpc::ProcessUnit::Clear();
  clear_has_unit_data();
}
inline const ::org::esb::rpc::ProcessUnit& ProcessUnitRequest::unit_data() const {
  return unit_data_ != NULL ? *unit_data_ : *default_instance_->unit_data_;
}
inline ::org::esb::rpc::ProcessUnit* ProcessUnitRequest::mutable_unit_data() {
  set_has_unit_data();
  if (unit_data_ == NULL) unit_data_ = new ::org::esb::rpc::ProcessUnit;
  return unit_data_;
}
inline ::org::esb::rpc::ProcessUnit* ProcessUnitRequest::release_unit_data() {
  clear_has_unit_data();
  ::org::esb::rpc::ProcessUnit* temp = unit_data_;
  unit_data_ = NULL;
  return temp;
}
inline void ProcessUnitRequest::set_allocated_unit_data(::org::esb::rpc::ProcessUnit* unit_data) {
  delete unit_data_;
  unit_data_ = unit_data;
  if (unit_data) {
    set_has_unit_data();
  } else {
    clear_has_unit_data();
  }
}

// -------------------------------------------------------------------

// ProcessUnitResponse

// optional .org.esb.rpc.ProcessUnit unit_data = 2;
inline bool ProcessUnitResponse::has_unit_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessUnitResponse::set_has_unit_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessUnitResponse::clear_has_unit_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessUnitResponse::clear_unit_data() {
  if (unit_data_ != NULL) unit_data_->::org::esb::rpc::ProcessUnit::Clear();
  clear_has_unit_data();
}
inline const ::org::esb::rpc::ProcessUnit& ProcessUnitResponse::unit_data() const {
  return unit_data_ != NULL ? *unit_data_ : *default_instance_->unit_data_;
}
inline ::org::esb::rpc::ProcessUnit* ProcessUnitResponse::mutable_unit_data() {
  set_has_unit_data();
  if (unit_data_ == NULL) unit_data_ = new ::org::esb::rpc::ProcessUnit;
  return unit_data_;
}
inline ::org::esb::rpc::ProcessUnit* ProcessUnitResponse::release_unit_data() {
  clear_has_unit_data();
  ::org::esb::rpc::ProcessUnit* temp = unit_data_;
  unit_data_ = NULL;
  return temp;
}
inline void ProcessUnitResponse::set_allocated_unit_data(::org::esb::rpc::ProcessUnit* unit_data) {
  delete unit_data_;
  unit_data_ = unit_data;
  if (unit_data) {
    set_has_unit_data();
  } else {
    clear_has_unit_data();
  }
}

// required string status = 3;
inline bool ProcessUnitResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessUnitResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessUnitResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessUnitResponse::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& ProcessUnitResponse::status() const {
  return *status_;
}
inline void ProcessUnitResponse::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void ProcessUnitResponse::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void ProcessUnitResponse::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessUnitResponse::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* ProcessUnitResponse::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessUnitResponse::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Process

// required string process_name = 1;
inline bool Process::has_process_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Process::set_has_process_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Process::clear_has_process_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Process::clear_process_name() {
  if (process_name_ != &::google::protobuf::internal::kEmptyString) {
    process_name_->clear();
  }
  clear_has_process_name();
}
inline const ::std::string& Process::process_name() const {
  return *process_name_;
}
inline void Process::set_process_name(const ::std::string& value) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void Process::set_process_name(const char* value) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(value);
}
inline void Process::set_process_name(const char* value, size_t size) {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  process_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Process::mutable_process_name() {
  set_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    process_name_ = new ::std::string;
  }
  return process_name_;
}
inline ::std::string* Process::release_process_name() {
  clear_has_process_name();
  if (process_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_name_;
    process_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Process::set_allocated_process_name(::std::string* process_name) {
  if (process_name_ != &::google::protobuf::internal::kEmptyString) {
    delete process_name_;
  }
  if (process_name) {
    set_has_process_name();
    process_name_ = process_name;
  } else {
    clear_has_process_name();
    process_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProcessRequest

// required .org.esb.rpc.Node node = 1;
inline bool ProcessRequest::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessRequest::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessRequest::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessRequest::clear_node() {
  if (node_ != NULL) node_->::org::esb::rpc::Node::Clear();
  clear_has_node();
}
inline const ::org::esb::rpc::Node& ProcessRequest::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::org::esb::rpc::Node* ProcessRequest::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::org::esb::rpc::Node;
  return node_;
}
inline ::org::esb::rpc::Node* ProcessRequest::release_node() {
  clear_has_node();
  ::org::esb::rpc::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void ProcessRequest::set_allocated_node(::org::esb::rpc::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
}

// optional .org.esb.rpc.Process process_data = 2;
inline bool ProcessRequest::has_process_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessRequest::set_has_process_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessRequest::clear_has_process_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessRequest::clear_process_data() {
  if (process_data_ != NULL) process_data_->::org::esb::rpc::Process::Clear();
  clear_has_process_data();
}
inline const ::org::esb::rpc::Process& ProcessRequest::process_data() const {
  return process_data_ != NULL ? *process_data_ : *default_instance_->process_data_;
}
inline ::org::esb::rpc::Process* ProcessRequest::mutable_process_data() {
  set_has_process_data();
  if (process_data_ == NULL) process_data_ = new ::org::esb::rpc::Process;
  return process_data_;
}
inline ::org::esb::rpc::Process* ProcessRequest::release_process_data() {
  clear_has_process_data();
  ::org::esb::rpc::Process* temp = process_data_;
  process_data_ = NULL;
  return temp;
}
inline void ProcessRequest::set_allocated_process_data(::org::esb::rpc::Process* process_data) {
  delete process_data_;
  process_data_ = process_data;
  if (process_data) {
    set_has_process_data();
  } else {
    clear_has_process_data();
  }
}

// -------------------------------------------------------------------

// ProcessResponse

// optional .org.esb.rpc.Process process_data = 2;
inline bool ProcessResponse::has_process_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessResponse::set_has_process_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessResponse::clear_has_process_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessResponse::clear_process_data() {
  if (process_data_ != NULL) process_data_->::org::esb::rpc::Process::Clear();
  clear_has_process_data();
}
inline const ::org::esb::rpc::Process& ProcessResponse::process_data() const {
  return process_data_ != NULL ? *process_data_ : *default_instance_->process_data_;
}
inline ::org::esb::rpc::Process* ProcessResponse::mutable_process_data() {
  set_has_process_data();
  if (process_data_ == NULL) process_data_ = new ::org::esb::rpc::Process;
  return process_data_;
}
inline ::org::esb::rpc::Process* ProcessResponse::release_process_data() {
  clear_has_process_data();
  ::org::esb::rpc::Process* temp = process_data_;
  process_data_ = NULL;
  return temp;
}
inline void ProcessResponse::set_allocated_process_data(::org::esb::rpc::Process* process_data) {
  delete process_data_;
  process_data_ = process_data;
  if (process_data) {
    set_has_process_data();
  } else {
    clear_has_process_data();
  }
}

// required string status_message = 3;
inline bool ProcessResponse::has_status_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessResponse::set_has_status_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessResponse::clear_has_status_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessResponse::clear_status_message() {
  if (status_message_ != &::google::protobuf::internal::kEmptyString) {
    status_message_->clear();
  }
  clear_has_status_message();
}
inline const ::std::string& ProcessResponse::status_message() const {
  return *status_message_;
}
inline void ProcessResponse::set_status_message(const ::std::string& value) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::kEmptyString) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(value);
}
inline void ProcessResponse::set_status_message(const char* value) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::kEmptyString) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(value);
}
inline void ProcessResponse::set_status_message(const char* value, size_t size) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::kEmptyString) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProcessResponse::mutable_status_message() {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::kEmptyString) {
    status_message_ = new ::std::string;
  }
  return status_message_;
}
inline ::std::string* ProcessResponse::release_status_message() {
  clear_has_status_message();
  if (status_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_message_;
    status_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProcessResponse::set_allocated_status_message(::std::string* status_message) {
  if (status_message_ != &::google::protobuf::internal::kEmptyString) {
    delete status_message_;
  }
  if (status_message) {
    set_has_status_message();
    status_message_ = status_message;
  } else {
    clear_has_status_message();
    status_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status_code = 4;
inline bool ProcessResponse::has_status_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessResponse::set_has_status_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessResponse::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessResponse::clear_status_code() {
  status_code_ = 0;
  clear_has_status_code();
}
inline ::google::protobuf::int32 ProcessResponse::status_code() const {
  return status_code_;
}
inline void ProcessResponse::set_status_code(::google::protobuf::int32 value) {
  set_has_status_code();
  status_code_ = value;
}

// -------------------------------------------------------------------

// ApiRequest

// -------------------------------------------------------------------

// Stream

// -------------------------------------------------------------------

// Mediafile

// required int32 id = 1;
inline bool Mediafile::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mediafile::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mediafile::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mediafile::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Mediafile::id() const {
  return id_;
}
inline void Mediafile::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string filename = 2;
inline bool Mediafile::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mediafile::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mediafile::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mediafile::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Mediafile::filename() const {
  return *filename_;
}
inline void Mediafile::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Mediafile::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Mediafile::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mediafile::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Mediafile::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Mediafile::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 size = 3;
inline bool Mediafile::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mediafile::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mediafile::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mediafile::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 Mediafile::size() const {
  return size_;
}
inline void Mediafile::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// required int64 duration = 4;
inline bool Mediafile::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mediafile::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mediafile::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mediafile::clear_duration() {
  duration_ = GOOGLE_LONGLONG(0);
  clear_has_duration();
}
inline ::google::protobuf::int64 Mediafile::duration() const {
  return duration_;
}
inline void Mediafile::set_duration(::google::protobuf::int64 value) {
  set_has_duration();
  duration_ = value;
}

// required int32 stream_count = 5;
inline bool Mediafile::has_stream_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mediafile::set_has_stream_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Mediafile::clear_has_stream_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Mediafile::clear_stream_count() {
  stream_count_ = 0;
  clear_has_stream_count();
}
inline ::google::protobuf::int32 Mediafile::stream_count() const {
  return stream_count_;
}
inline void Mediafile::set_stream_count(::google::protobuf::int32 value) {
  set_has_stream_count();
  stream_count_ = value;
}

// required string format = 6;
inline bool Mediafile::has_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Mediafile::set_has_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Mediafile::clear_has_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Mediafile::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& Mediafile::format() const {
  return *format_;
}
inline void Mediafile::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void Mediafile::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void Mediafile::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mediafile::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* Mediafile::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Mediafile::set_allocated_format(::std::string* format) {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .org.esb.rpc.Stream streams = 7;
inline int Mediafile::streams_size() const {
  return streams_.size();
}
inline void Mediafile::clear_streams() {
  streams_.Clear();
}
inline const ::org::esb::rpc::Stream& Mediafile::streams(int index) const {
  return streams_.Get(index);
}
inline ::org::esb::rpc::Stream* Mediafile::mutable_streams(int index) {
  return streams_.Mutable(index);
}
inline ::org::esb::rpc::Stream* Mediafile::add_streams() {
  return streams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream >&
Mediafile::streams() const {
  return streams_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Stream >*
Mediafile::mutable_streams() {
  return &streams_;
}

// -------------------------------------------------------------------

// MediafileList

// repeated .org.esb.rpc.Mediafile mediafiles = 1;
inline int MediafileList::mediafiles_size() const {
  return mediafiles_.size();
}
inline void MediafileList::clear_mediafiles() {
  mediafiles_.Clear();
}
inline const ::org::esb::rpc::Mediafile& MediafileList::mediafiles(int index) const {
  return mediafiles_.Get(index);
}
inline ::org::esb::rpc::Mediafile* MediafileList::mutable_mediafiles(int index) {
  return mediafiles_.Mutable(index);
}
inline ::org::esb::rpc::Mediafile* MediafileList::add_mediafiles() {
  return mediafiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >&
MediafileList::mediafiles() const {
  return mediafiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >*
MediafileList::mutable_mediafiles() {
  return &mediafiles_;
}

// -------------------------------------------------------------------

// MediafileRequest

// optional .org.esb.rpc.Mediafile file = 1;
inline bool MediafileRequest::has_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediafileRequest::set_has_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediafileRequest::clear_has_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediafileRequest::clear_file() {
  if (file_ != NULL) file_->::org::esb::rpc::Mediafile::Clear();
  clear_has_file();
}
inline const ::org::esb::rpc::Mediafile& MediafileRequest::file() const {
  return file_ != NULL ? *file_ : *default_instance_->file_;
}
inline ::org::esb::rpc::Mediafile* MediafileRequest::mutable_file() {
  set_has_file();
  if (file_ == NULL) file_ = new ::org::esb::rpc::Mediafile;
  return file_;
}
inline ::org::esb::rpc::Mediafile* MediafileRequest::release_file() {
  clear_has_file();
  ::org::esb::rpc::Mediafile* temp = file_;
  file_ = NULL;
  return temp;
}
inline void MediafileRequest::set_allocated_file(::org::esb::rpc::Mediafile* file) {
  delete file_;
  file_ = file;
  if (file) {
    set_has_file();
  } else {
    clear_has_file();
  }
}

// -------------------------------------------------------------------

// MediafileResponse

// repeated .org.esb.rpc.Mediafile mediafiles = 1;
inline int MediafileResponse::mediafiles_size() const {
  return mediafiles_.size();
}
inline void MediafileResponse::clear_mediafiles() {
  mediafiles_.Clear();
}
inline const ::org::esb::rpc::Mediafile& MediafileResponse::mediafiles(int index) const {
  return mediafiles_.Get(index);
}
inline ::org::esb::rpc::Mediafile* MediafileResponse::mutable_mediafiles(int index) {
  return mediafiles_.Mutable(index);
}
inline ::org::esb::rpc::Mediafile* MediafileResponse::add_mediafiles() {
  return mediafiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >&
MediafileResponse::mediafiles() const {
  return mediafiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::esb::rpc::Mediafile >*
MediafileResponse::mutable_mediafiles() {
  return &mediafiles_;
}

// required int32 status = 2;
inline bool MediafileResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediafileResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediafileResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediafileResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 MediafileResponse::status() const {
  return status_;
}
inline void MediafileResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// User

// required string name = 1;
inline bool User::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& User::name() const {
  return *name_;
}
inline void User::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void User::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void User::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* User::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pass = 2;
inline bool User::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_pass() {
  if (pass_ != &::google::protobuf::internal::kEmptyString) {
    pass_->clear();
  }
  clear_has_pass();
}
inline const ::std::string& User::pass() const {
  return *pass_;
}
inline void User::set_pass(const ::std::string& value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::kEmptyString) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
}
inline void User::set_pass(const char* value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::kEmptyString) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
}
inline void User::set_pass(const char* value, size_t size) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::kEmptyString) {
    pass_ = new ::std::string;
  }
  pass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_pass() {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::kEmptyString) {
    pass_ = new ::std::string;
  }
  return pass_;
}
inline ::std::string* User::release_pass() {
  clear_has_pass();
  if (pass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pass_;
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_pass(::std::string* pass) {
  if (pass_ != &::google::protobuf::internal::kEmptyString) {
    delete pass_;
  }
  if (pass) {
    set_has_pass();
    pass_ = pass;
  } else {
    clear_has_pass();
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthToken

// required string token = 1;
inline bool AuthToken::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthToken::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthToken::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthToken::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AuthToken::token() const {
  return *token_;
}
inline void AuthToken::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AuthToken::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AuthToken::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthToken::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AuthToken::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthToken::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace esb
}  // namespace org

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::org::esb::rpc::ErrorReason>() {
  return ::org::esb::rpc::ErrorReason_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rpc_2eproto__INCLUDED
